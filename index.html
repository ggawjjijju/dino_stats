<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8">
<title>부서진 도형 복원기 (Bezier + Circle Fit)</title>
<style>
  :root { --w:1080px; }
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif; margin: 20px; }
  h1 { margin: 0 0 8px; }
  p  { margin: 6px 0 10px; color:#333; }
  .row { display: grid; grid-template-columns: 1fr 340px; gap: 16px; align-items: start; }
  canvas { width: var(--w); height: 600px; border:1px solid #ddd; background:#fff; }
  button { margin:4px 4px 0 0; }
  input[type="range"] { width:100%; }
  .hint { color:#666; font-size:12px; }
  #log { font-size:12px; white-space:pre-wrap; background:#fff; border:1px solid #eee; padding:8px; height:160px; overflow:auto;}
</style>
</head>
<body>

<h1>부서진 곡선 복원기 (Bezier + Circle Fit)</h1>
<p class="hint">조각난 선을 그리면 전체 곡선을 자동으로 복원합니다. 반원 일부만 있어도 원으로 복원됩니다.</p>

<div class="row">
  <div>
    <canvas id="cv" width="1080" height="600"></canvas>
    <div style="margin-top:8px;">
      <button id="modeOpen">그리기: 폴리라인</button>
      <button id="modeClosed">그리기: 폴리곤</button>
      <button id="finishContour">현재 윤곽 종료</button>
      <button id="undoPoint">마지막 점 취소</button>
      <button id="clearAll">모두 지우기</button>
    </div>
  </div>

  <div>
    <h2>입출력</h2>
    <input id="svgfile" type="file" accept=".svg">
    <button id="loadSvg">SVG 불러오기</button><br><br>

    <input id="jsonfile" type="file" accept=".json">
    <button id="loadJson">JSON 불러오기</button><br><br>

    <button id="exportSvg">SVG 저장</button>
    <button id="exportJson">JSON 저장</button>

    <h2>옵션</h2>
    <label>스무딩(0~1): <span id="smoothVal">0.6</span></label>
    <input id="smooth" type="range" min="0" max="1" step="0.05" value="0.6">

    <h2>복원</h2>
    <button id="heal">복원 실행</button>

    <h2>로그</h2>
    <div id="log">대기중…</div>
  </div>
</div>

<script>
// =======================================================
// 상태
// =======================================================
const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
const logEl=document.getElementById('log');
function log(t){ logEl.textContent += "\n" + t; logEl.scrollTop=logEl.scrollHeight; }
function clearLog(){ logEl.textContent=""; }

const state={
  mode:'open',
  current:[],
  openPolylines:[],
  closedContours:[],
  bezierResult: null
};

// =======================================================
// 기본 함수
// =======================================================
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function ensureClosed(ct){
  const f=ct[0], l=ct[ct.length-1];
  if(f.x!==l.x||f.y!==l.y) ct.push({x:f.x,y:f.y});
}

// =======================================================
// 원 피팅(Kasa)
// =======================================================
function fitCircle(points){
  let sumX=0,sumY=0,sumX2=0,sumY2=0,sumXY=0;
  const n=points.length;
  for(const p of points){
    sumX+=p.x; sumY+=p.y;
    sumX2+=p.x*p.x; sumY2+=p.y*p.y;
    sumXY+=p.x*p.y;
  }
  const A=n*sumX2 - sumX*sumX;
  const B=n*sumXY - sumX*sumY;
  const C=n*(sumX2+sumY2)-(sumX*sumX + sumY*sumY);
  const denom=2*(A*(n*sumY2 - sumY*sumY) - B*B);
  if(Math.abs(denom)<1e-9) return null;

  const cy=(A*(n*sumY2 - sumY*sumY) - B*(n*sumXY - sumX*sumY))/denom;
  const cx=(sumX - sumY*cy)/A * 0.5;
  const r=Math.hypot(points[0].x-cx, points[0].y-cy);
  return {cx,cy,r};
}

// =======================================================
// Bezier spline (Catmull-Rom → cubic Bezier)
// =======================================================
function splineToBezier(pts, alpha=0.5){
  if(pts.length<2) return [];
  const out=[];
  out.push({type:"M", x:pts[0].x, y:pts[0].y});
  const n=pts.length;

  function P(i){
    if(i<0) return pts[0];
    if(i>=n) return pts[n-1];
    return pts[i];
  }

  for(let i=0;i<n-1;i++){
    const p0=P(i-1), p1=P(i), p2=P(i+1), p3=P(i+2);
    const t=alpha/6;
    const cp1={x:p1.x+(p2.x-p0.x)*t, y:p1.y+(p2.y-p0.y)*t};
    const cp2={x:p2.x-(p3.x-p1.x)*t, y:p2.y-(p3.y-p1.y)*t};
    out.push({
      type:"C",
      x1:cp1.x,y1:cp1.y,
      x2:cp2.x,y2:cp2.y,
      x:p2.x, y:p2.y
    });
  }
  return out;
}

// =======================================================
// 원호 → Bezier
// =======================================================
function arcSegmentToBezier(cx,cy,r,a0,a1){
  const cos=Math.cos, sin=Math.sin;
  const p0={x:cx+r*cos(a0), y:cy+r*sin(a0)};
  const p3={x:cx+r*cos(a1), y:cy+r*sin(a1)};
  const t=Math.tan((a1-a0)/4);
  const hx=r*t;

  const cp1={x:p0.x - hx*sin(a0), y:p0.y + hx*cos(a0)};
  const cp2={x:p3.x + hx*sin(a1), y:p3.y - hx*cos(a1)};
  return {p0, cp1, cp2, p3};
}

function arcToBeziers(cx,cy,r,a0,a1){
  const sweep=a1-a0;
  const parts=Math.ceil(Math.abs(sweep)/(Math.PI/2));
  const step=sweep/parts;
  const segs=[];
  for(let i=0;i<parts;i++){
    const t0=a0+step*i;
    const t1=a0+step*(i+1);
    segs.push(arcSegmentToBezier(cx,cy,r,t0,t1));
  }
  return segs;
}

// =======================================================
// ★ “곡률 기반 복원” 핵심 함수 (전체 교체됨)
// =======================================================
function healBrokenShape({closedContours=[],openPolylines=[]}, opts){
  // 0) 모든 점을 하나로 통합
  const pts=[];
  for(const ct of closedContours) for(const p of ct) pts.push({...p});
  for(const ln of openPolylines) for(const p of ln) pts.push({...p});
  if(pts.length<3) return [];

  // 1) 정렬 (대략적인 순서 추정)
  pts.sort((a,b)=>a.x===b.x ? a.y-b.y : a.x-b.x);

  // 2) 곡률 분석
  const diffs=[];
  for(let i=1;i<pts.length-1;i++){
    const a=pts[i-1], b=pts[i], c=pts[i+1];
    const ang=Math.abs(
      Math.atan2(c.y-b.y,c.x-b.x) - Math.atan2(b.y-a.y,b.x-a.x)
    );
    diffs.push(ang);
  }
  const meanAng=diffs.reduce((s,v)=>s+v,0)/diffs.length;
  const looksLikeArc = meanAng > 0.1;

  let bezierPaths=[];

  // 3) 원인지 판단
  if(looksLikeArc){
    const fit=fitCircle(pts);
    if(fit){
      let a0=Math.atan2(pts[0].y-fit.cy, pts[0].x-fit.cx);
      let a1=Math.atan2(pts[pts.length-1].y-fit.cy, pts[pts.length-1].x-fit.cx);

      const segs=arcToBeziers(fit.cx,fit.cy,fit.r,a0,a1);
      const path=[{type:"M", x:segs[0].p0.x, y:segs[0].p0.y}];
      for(const sg of segs){
        path.push({
          type:"C",
          x1:sg.cp1.x, y1:sg.cp1.y,
          x2:sg.cp2.x, y2:sg.cp2.y,
          x:sg.p3.x,   y:sg.p3.y
        });
      }
      bezierPaths.push(path);
    } else {
      bezierPaths.push(splineToBezier(pts, Number(smooth.value)));
    }
  } else {
    bezierPaths.push(splineToBezier(pts, Number(smooth.value)));
  }

  return bezierPaths;
}

// =======================================================
// Canvas 렌더링 (Bezier)
// =======================================================
function draw(){
  ctx.clearRect(0,0,cv.width,cv.height);

  // 원본 점/선
  ctx.strokeStyle="#aaa"; ctx.lineWidth=1.2;
  for(const ct of state.closedContours){
    ctx.beginPath();
    for(let i=0;i<ct.length;i++){
      if(i===0) ctx.moveTo(ct[i].x, ct[i].y);
      else ctx.lineTo(ct[i].x, ct[i].y);
    }
    ctx.stroke();
  }
  for(const ln of state.openPolylines){
    ctx.beginPath();
    for(let i=0;i<ln.length;i++){
      if(i===0) ctx.moveTo(ln[i].x, ln[i].y);
      else ctx.lineTo(ln[i].x, ln[i].y);
    }
    ctx.stroke();
  }

  // 현재 입력 중 점
  if(state.current.length){
    ctx.strokeStyle="#000"; ctx.setLineDash([5,3]);
    ctx.beginPath();
    for(let i=0;i<state.current.length;i++){
      const p=state.current[i];
      if(i===0) ctx.moveTo(p.x,p.y);
      else ctx.lineTo(p.x,p.y);
    }
    ctx.stroke(); ctx.setLineDash([]);

    ctx.fillStyle="#000";
    for(const p of state.current){
      ctx.beginPath(); ctx.arc(p.x,p.y,3,0,Math.PI*2);
      ctx.fill();
    }
  }

  // 베지에 복원 결과
  if(state.bezierResult){
    ctx.strokeStyle="#ff4b00"; ctx.lineWidth=2.0;
    for(const path of state.bezierResult){
      ctx.beginPath();
      for(const cmd of path){
        if(cmd.type==="M") ctx.moveTo(cmd.x,cmd.y);
        else if(cmd.type==="C") ctx.bezierCurveTo(cmd.x1,cmd.y1,cmd.x2,cmd.y2,cmd.x,cmd.y);
      }
      ctx.stroke();
    }
  }
}
draw();

// =======================================================
// Canvas 클릭 → 점 입력
// =======================================================
cv.addEventListener('click', e=>{
  const r=cv.getBoundingClientRect();
  const x=e.clientX-r.left, y=e.clientY-r.top;
  state.current.push({x,y});
  draw();
});

// =======================================================
// 버튼 동작
// =======================================================
document.getElementById('modeOpen').onclick=()=>state.mode='open';
document.getElementById('modeClosed').onclick=()=>state.mode='closed';

document.getElementById('undoPoint').onclick=()=>{
  state.current.pop(); draw();
};

document.getElementById('clearAll').onclick=()=>{
  state.current=[]; state.openPolylines=[]; state.closedContours=[];
  state.bezierResult=null; clearLog(); draw();
};

document.getElementById('finishContour').onclick=()=>{
  if(state.current.length<2) return;
  const ct=state.current.slice();
  if(state.mode==='closed') ensureClosed(ct);
  if(state.mode==='closed') state.closedContours.push(ct);
  else state.openPolylines.push(ct);
  state.current=[]; draw();
};

// =======================================================
// 복원 실행
// =======================================================
const smooth=document.getElementById('smooth');
document.getElementById('heal').onclick=()=>{
  const res = healBrokenShape({
    closedContours:state.closedContours,
    openPolylines:state.openPolylines
  });
  state.bezierResult=res;
  draw();
  log("곡선 복원 완료: 베지에 경로 "+res.length+"개");
};

// =======================================================
// SVG / JSON 내보내기
// =======================================================
function download(name, blob){
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url; a.download=name; a.click();
  setTimeout(()=>URL.revokeObjectURL(url),100);
}

document.getElementById('exportSvg').onclick=()=>{
  if(!state.bezierResult){ log("복원된 결과 없음"); return;}

  function toD(path){
    const out=[];
    for(const c of path){
      if(c.type==="M") out.push(`M${c.x} ${c.y}`);
      else out.push(`C${c.x1} ${c.y1} ${c.x2} ${c.y2} ${c.x} ${c.y}`);
    }
    return out.join(" ");
  }

  const d = state.bezierResult.map(toD).join(" ");
  const svg=`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${cv.width} ${cv.height}">
  <path d="${d}" fill="none" stroke="black"/>
</svg>`;
  download("healed.svg", new Blob([svg],{type:"image/svg+xml"}));
  log("SVG 저장 완료");
};

document.getElementById('exportJson').onclick=()=>{
  const data=JSON.stringify({bezier:state.bezierResult},null,2);
  download("healed.json", new Blob([data],{type:"application/json"}));
  log("JSON 저장 완료");
};

// =======================================================
// SVG/JSON 불러오기 (polyline/polygon만)
// =======================================================
document.getElementById('loadSvg').onclick=async()=>{
  const f=document.getElementById('svgfile').files[0];
  if(!f){ log("파일 선택 없음"); return; }
  const txt=await f.text();
  try{
    const dom=new DOMParser().parseFromString(txt,"image/svg+xml");
    const polys=[...dom.querySelectorAll('polygon')];
    const lines=[...dom.querySelectorAll('polyline')];
    let cc=[], oo=[];

    function parsePoints(ps){
      const nums=ps.trim().split(/[ ,]+/).map(Number).filter(n=>isFinite(n));
      const arr=[];
      for(let i=0;i<nums.length;i+=2)
        arr.push({x:nums[i], y:nums[i+1]});
      return arr;
    }

    for(const p of polys){
      const arr=parsePoints(p.getAttribute('points')||'');
      if(arr.length>2){ ensureClosed(arr); cc.push(arr); }
    }
    for(const p of lines){
      const arr=parsePoints(p.getAttribute('points')||'');
      if(arr.length>1) oo.push(arr);
    }

    state.current=[]; state.openPolylines=oo; state.closedContours=cc;
    state.bezierResult=null; draw();
    log("SVG 불러오기 완료");
  }catch(e){
    log("SVG 파싱 실패: "+e.message);
  }
};

document.getElementById('loadJson').onclick=async()=>{
  const f=document.getElementById('jsonfile').files[0];
  if(!f){ log("파일 선택 없음"); return; }
  const obj=JSON.parse(await f.text());
  state.bezierResult=null;
  state.openPolylines=(obj.openPolylines||[]);
  state.closedContours=(obj.closedContours||[]);
  draw();
  log("JSON 불러오기 완료");
};
</script>

</body>
</html>
